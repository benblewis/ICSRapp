{"ast":null,"code":"/***************************************************************************\n * The contents of this file were generated with Amplify Studio.           *\n * Please refrain from making any modifications to this file.              *\n * Any changes to this file will be overwritten when running amplify pull. *\n **************************************************************************/\n\n/* eslint-disable */\nexport const validateField = (value, validations) => {\n  for (const validation of validations) {\n    if (value === undefined || value === \"\" || value === null) {\n      if (validation.type === \"Required\") {\n        return {\n          hasError: true,\n          errorMessage: validation.validationMessage || \"The value is required\"\n        };\n      } else {\n        return {\n          hasError: false\n        };\n      }\n    }\n    const validationResult = checkValidation(value, validation);\n    if (validationResult !== null && validationResult !== void 0 && validationResult.hasError) {\n      return validationResult;\n    }\n  }\n  return {\n    hasError: false\n  };\n};\nexport const parseDateValidator = dateValidator => {\n  const isTimestamp = `${parseInt(dateValidator)}`.length === dateValidator.length;\n  return isTimestamp ? parseInt(dateValidator) : dateValidator;\n};\nconst checkValidation = (value, validation) => {\n  var _validation$numValues, _validation$strValues;\n  if ((_validation$numValues = validation.numValues) !== null && _validation$numValues !== void 0 && _validation$numValues.length) {\n    switch (validation.type) {\n      case \"LessThanChar\":\n        return {\n          hasError: !(value.length <= validation.numValues[0]),\n          errorMessage: validation.validationMessage || `The value must be shorter than ${validation.numValues[0]}`\n        };\n      case \"GreaterThanChar\":\n        return {\n          hasError: !(value.length > validation.numValues[0]),\n          errorMessage: validation.validationMessage || `The value must be longer than ${validation.numValues[0]}`\n        };\n      case \"LessThanNum\":\n        return {\n          hasError: !(value < validation.numValues[0]),\n          errorMessage: validation.validationMessage || `The value must be less than ${validation.numValues[0]}`\n        };\n      case \"GreaterThanNum\":\n        return {\n          hasError: !(value > validation.numValues[0]),\n          errorMessage: validation.validationMessage || `The value must be greater than ${validation.numValues[0]}`\n        };\n      case \"EqualTo\":\n        return {\n          hasError: !validation.numValues.some(el => el === value),\n          errorMessage: validation.validationMessage || `The value must be equal to ${validation.numValues.join(\" or \")}`\n        };\n      default:\n    }\n  } else if ((_validation$strValues = validation.strValues) !== null && _validation$strValues !== void 0 && _validation$strValues.length) {\n    switch (validation.type) {\n      case \"StartWith\":\n        return {\n          hasError: !validation.strValues.some(el => value.startsWith(el)),\n          errorMessage: validation.validationMessage || `The value must start with ${validation.strValues.join(\", \")}`\n        };\n      case \"EndWith\":\n        return {\n          hasError: !validation.strValues.some(el => value.endsWith(el)),\n          errorMessage: validation.validationMessage || `The value must end with ${validation.strValues.join(\", \")}`\n        };\n      case \"Contains\":\n        return {\n          hasError: !validation.strValues.some(el => value.includes(el)),\n          errorMessage: validation.validationMessage || `The value must contain ${validation.strValues.join(\", \")}`\n        };\n      case \"NotContains\":\n        return {\n          hasError: !validation.strValues.every(el => !value.includes(el)),\n          errorMessage: validation.validationMessage || `The value must not contain ${validation.strValues.join(\", \")}`\n        };\n      case \"BeAfter\":\n        return {\n          hasError: !(new Date(value) > new Date(parseDateValidator(validation.strValues[0]))),\n          errorMessage: validation.validationMessage || `The value must be after ${validation.strValues[0]}`\n        };\n      case \"BeBefore\":\n        return {\n          hasError: !(new Date(value) < new Date(parseDateValidator(validation.strValues[0]))),\n          errorMessage: validation.validationMessage || `The value must be before ${validation.strValues[0]}`\n        };\n    }\n  }\n  switch (validation.type) {\n    case \"Email\":\n      const EMAIL_ADDRESS_REGEX = /^[-!#$%&'*+\\/0-9=?A-Z^_a-z`{|}~](\\.?[-!#$%&'*+\\/0-9=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*\\.?[a-zA-Z0-9])*\\.[a-zA-Z](-?[a-zA-Z0-9])+$/;\n      return {\n        hasError: !EMAIL_ADDRESS_REGEX.test(value),\n        errorMessage: validation.validationMessage || \"The value must be a valid email address\"\n      };\n    case \"JSON\":\n      let isInvalidJSON = false;\n      try {\n        JSON.parse(value);\n      } catch (e) {\n        isInvalidJSON = true;\n      }\n      return {\n        hasError: isInvalidJSON,\n        errorMessage: validation.validationMessage || \"The value must be in a correct JSON format\"\n      };\n    case \"IpAddress\":\n      const IPV_4 = /^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$/;\n      const IPV_6 = /^(?:(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$/;\n      return {\n        hasError: !(IPV_4.test(value) || IPV_6.test(value)),\n        errorMessage: validation.validationMessage || \"The value must be an IPv4 or IPv6 address\"\n      };\n    case \"URL\":\n      let isInvalidUrl = false;\n      try {\n        new URL(value);\n      } catch (e) {\n        isInvalidUrl = true;\n      }\n      return {\n        hasError: isInvalidUrl,\n        errorMessage: validation.validationMessage || \"The value must be a valid URL that begins with a schema (i.e. http:// or mailto:)\"\n      };\n    case \"Phone\":\n      const PHONE = /^\\+?\\d[\\d\\s-]+$/;\n      return {\n        hasError: !PHONE.test(value),\n        errorMessage: validation.validationMessage || \"The value must be a valid phone number\"\n      };\n    default:\n  }\n};\nconst monthToShortMon = {\n  \"1\": \"Jan\",\n  \"2\": \"Feb\",\n  \"3\": \"Mar\",\n  \"4\": \"Apr\",\n  \"5\": \"May\",\n  \"6\": \"Jun\",\n  \"7\": \"Jul\",\n  \"8\": \"Aug\",\n  \"9\": \"Sep\",\n  \"10\": \"Oct\",\n  \"11\": \"Nov\",\n  \"12\": \"Dec\"\n};\nconst invalidDateStr = \"Invalid Date\";\nexport function formatDate(date, dateFormat) {\n  if (date === undefined || date === null) {\n    return date;\n  }\n  const validDate = new Date(Date.parse(date));\n  if (validDate.toString() === invalidDateStr) {\n    return date;\n  }\n  const splitDate = date.split(/-|\\+|Z/);\n  const year = splitDate[0];\n  const month = splitDate[1];\n  const day = splitDate[2];\n  const truncatedMonth = month.replace(/^0+/, \"\");\n  switch (dateFormat) {\n    case \"locale\":\n      return validDate.toLocaleDateString();\n    case \"YYYY.MM.DD\":\n      return `${year}.${month}.${day}`;\n    case \"DD.MM.YYYY\":\n      return `${day}.${month}.${year}`;\n    case \"MM/DD/YYYY\":\n      return `${month}/${day}/${year}`;\n    case \"Mmm DD, YYYY\":\n      return `${monthToShortMon[truncatedMonth]} ${day}, ${year}`;\n    default:\n      return date;\n  }\n}\nexport function formatTime(time, timeFormat) {\n  if (time === undefined || time === null) {\n    return time;\n  }\n  const splitTime = time.split(/:|Z/);\n  if (splitTime.length < 3) {\n    return time;\n  }\n  const validTime = new Date();\n  validTime.setHours(Number.parseInt(splitTime[0], 10));\n  validTime.setMinutes(Number.parseInt(splitTime[1], 10));\n  const splitSeconds = splitTime[2].split(\".\");\n  validTime.setSeconds(Number.parseInt(splitSeconds[0], 10), Number.parseInt(splitSeconds[1], 10));\n  if (validTime.toString() === invalidDateStr) {\n    return time;\n  }\n  switch (timeFormat) {\n    case \"locale\":\n      return validTime.toLocaleTimeString();\n    case \"hours24\":\n      return validTime.toLocaleTimeString(\"en-gb\");\n    case \"hours12\":\n      return validTime.toLocaleTimeString(\"en-us\");\n    default:\n      return time;\n  }\n}\nexport function formatDateTime(dateTimeStr, dateTimeFormat) {\n  if (dateTimeStr === undefined || dateTimeStr === null) {\n    return dateTimeStr;\n  }\n  const dateTime = /^d+$/.test(dateTimeStr) ? new Date(Number.parseInt(dateTimeStr, 10)) : new Date(Date.parse(dateTimeStr));\n  if (dateTime.toString() === invalidDateStr) {\n    return dateTimeStr;\n  }\n  if (dateTimeFormat === \"locale\") {\n    return dateTime.toLocaleString();\n  }\n  const dateAndTime = dateTime.toISOString().split(\"T\");\n  const date = formatDate(dateAndTime[0], dateTimeFormat.dateFormat);\n  const time = formatTime(dateAndTime[1], dateTimeFormat.timeFormat);\n  return `${date} - ${time}`;\n}\nexport function formatter(value, formatterInput) {\n  switch (formatterInput.type) {\n    case \"DateFormat\":\n      return formatDate(value, formatterInput.format);\n    case \"DateTimeFormat\":\n      return formatDateTime(value, formatterInput.format);\n    case \"TimeFormat\":\n      return formatTime(value, formatterInput.format);\n    default:\n      return value;\n  }\n}\nexport const fetchByPath = (input, path = \"\", accumlator = []) => {\n  const currentPath = path.split(\".\");\n  const head = currentPath.shift();\n  if (input && head && input[head] !== undefined) {\n    if (!currentPath.length) {\n      accumlator.push(input[head]);\n    } else {\n      fetchByPath(input[head], currentPath.join(\".\"), accumlator);\n    }\n  }\n  return accumlator[0];\n};\nexport const processFile = async ({\n  file\n}) => {\n  const fileExtension = file.name.split(\".\").pop();\n  return file.arrayBuffer().then(filebuffer => window.crypto.subtle.digest(\"SHA-1\", filebuffer)).then(hashBuffer => {\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n    return {\n      file,\n      key: `${hashHex}.${fileExtension}`\n    };\n  });\n};","map":{"version":3,"names":["validateField","value","validations","validation","undefined","type","hasError","errorMessage","validationMessage","validationResult","checkValidation","parseDateValidator","dateValidator","isTimestamp","parseInt","length","_validation$numValues","_validation$strValues","numValues","some","el","join","strValues","startsWith","endsWith","includes","every","Date","EMAIL_ADDRESS_REGEX","test","isInvalidJSON","JSON","parse","e","IPV_4","IPV_6","isInvalidUrl","URL","PHONE","monthToShortMon","invalidDateStr","formatDate","date","dateFormat","validDate","toString","splitDate","split","year","month","day","truncatedMonth","replace","toLocaleDateString","formatTime","time","timeFormat","splitTime","validTime","setHours","Number","setMinutes","splitSeconds","setSeconds","toLocaleTimeString","formatDateTime","dateTimeStr","dateTimeFormat","dateTime","toLocaleString","dateAndTime","toISOString","formatter","formatterInput","format","fetchByPath","input","path","accumlator","currentPath","head","shift","push","processFile","file","fileExtension","name","pop","arrayBuffer","then","filebuffer","window","crypto","subtle","digest","hashBuffer","hashArray","Array","from","Uint8Array","hashHex","map","a","padStart","key"],"sources":["C:/Users/Benjamin Lewis/ICSR Database/icsr-app/src/ui-components/utils.js"],"sourcesContent":["/***************************************************************************\n * The contents of this file were generated with Amplify Studio.           *\n * Please refrain from making any modifications to this file.              *\n * Any changes to this file will be overwritten when running amplify pull. *\n **************************************************************************/\n\n/* eslint-disable */\nexport const validateField = (value, validations) => {\n  for (const validation of validations) {\n    if (value === undefined || value === \"\" || value === null) {\n      if (validation.type === \"Required\") {\n        return {\n          hasError: true,\n          errorMessage: validation.validationMessage || \"The value is required\",\n        };\n      } else {\n        return {\n          hasError: false,\n        };\n      }\n    }\n    const validationResult = checkValidation(value, validation);\n    if (validationResult?.hasError) {\n      return validationResult;\n    }\n  }\n  return { hasError: false };\n};\nexport const parseDateValidator = (dateValidator) => {\n  const isTimestamp =\n    `${parseInt(dateValidator)}`.length === dateValidator.length;\n  return isTimestamp ? parseInt(dateValidator) : dateValidator;\n};\nconst checkValidation = (value, validation) => {\n  if (validation.numValues?.length) {\n    switch (validation.type) {\n      case \"LessThanChar\":\n        return {\n          hasError: !(value.length <= validation.numValues[0]),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must be shorter than ${validation.numValues[0]}`,\n        };\n      case \"GreaterThanChar\":\n        return {\n          hasError: !(value.length > validation.numValues[0]),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must be longer than ${validation.numValues[0]}`,\n        };\n      case \"LessThanNum\":\n        return {\n          hasError: !(value < validation.numValues[0]),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must be less than ${validation.numValues[0]}`,\n        };\n      case \"GreaterThanNum\":\n        return {\n          hasError: !(value > validation.numValues[0]),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must be greater than ${validation.numValues[0]}`,\n        };\n      case \"EqualTo\":\n        return {\n          hasError: !validation.numValues.some((el) => el === value),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must be equal to ${validation.numValues.join(\" or \")}`,\n        };\n      default:\n    }\n  } else if (validation.strValues?.length) {\n    switch (validation.type) {\n      case \"StartWith\":\n        return {\n          hasError: !validation.strValues.some((el) => value.startsWith(el)),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must start with ${validation.strValues.join(\", \")}`,\n        };\n      case \"EndWith\":\n        return {\n          hasError: !validation.strValues.some((el) => value.endsWith(el)),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must end with ${validation.strValues.join(\", \")}`,\n        };\n      case \"Contains\":\n        return {\n          hasError: !validation.strValues.some((el) => value.includes(el)),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must contain ${validation.strValues.join(\", \")}`,\n        };\n      case \"NotContains\":\n        return {\n          hasError: !validation.strValues.every((el) => !value.includes(el)),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must not contain ${validation.strValues.join(\", \")}`,\n        };\n      case \"BeAfter\":\n        return {\n          hasError: !(\n            new Date(value) >\n            new Date(parseDateValidator(validation.strValues[0]))\n          ),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must be after ${validation.strValues[0]}`,\n        };\n      case \"BeBefore\":\n        return {\n          hasError: !(\n            new Date(value) <\n            new Date(parseDateValidator(validation.strValues[0]))\n          ),\n          errorMessage:\n            validation.validationMessage ||\n            `The value must be before ${validation.strValues[0]}`,\n        };\n    }\n  }\n  switch (validation.type) {\n    case \"Email\":\n      const EMAIL_ADDRESS_REGEX =\n        /^[-!#$%&'*+\\/0-9=?A-Z^_a-z`{|}~](\\.?[-!#$%&'*+\\/0-9=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*\\.?[a-zA-Z0-9])*\\.[a-zA-Z](-?[a-zA-Z0-9])+$/;\n      return {\n        hasError: !EMAIL_ADDRESS_REGEX.test(value),\n        errorMessage:\n          validation.validationMessage ||\n          \"The value must be a valid email address\",\n      };\n    case \"JSON\":\n      let isInvalidJSON = false;\n      try {\n        JSON.parse(value);\n      } catch (e) {\n        isInvalidJSON = true;\n      }\n      return {\n        hasError: isInvalidJSON,\n        errorMessage:\n          validation.validationMessage ||\n          \"The value must be in a correct JSON format\",\n      };\n    case \"IpAddress\":\n      const IPV_4 =\n        /^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$/;\n      const IPV_6 =\n        /^(?:(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$/;\n      return {\n        hasError: !(IPV_4.test(value) || IPV_6.test(value)),\n        errorMessage:\n          validation.validationMessage ||\n          \"The value must be an IPv4 or IPv6 address\",\n      };\n    case \"URL\":\n      let isInvalidUrl = false;\n      try {\n        new URL(value);\n      } catch (e) {\n        isInvalidUrl = true;\n      }\n      return {\n        hasError: isInvalidUrl,\n        errorMessage:\n          validation.validationMessage ||\n          \"The value must be a valid URL that begins with a schema (i.e. http:// or mailto:)\",\n      };\n    case \"Phone\":\n      const PHONE = /^\\+?\\d[\\d\\s-]+$/;\n      return {\n        hasError: !PHONE.test(value),\n        errorMessage:\n          validation.validationMessage ||\n          \"The value must be a valid phone number\",\n      };\n    default:\n  }\n};\nconst monthToShortMon = {\n  \"1\": \"Jan\",\n  \"2\": \"Feb\",\n  \"3\": \"Mar\",\n  \"4\": \"Apr\",\n  \"5\": \"May\",\n  \"6\": \"Jun\",\n  \"7\": \"Jul\",\n  \"8\": \"Aug\",\n  \"9\": \"Sep\",\n  \"10\": \"Oct\",\n  \"11\": \"Nov\",\n  \"12\": \"Dec\",\n};\nconst invalidDateStr = \"Invalid Date\";\nexport function formatDate(date, dateFormat) {\n  if (date === undefined || date === null) {\n    return date;\n  }\n  const validDate = new Date(Date.parse(date));\n  if (validDate.toString() === invalidDateStr) {\n    return date;\n  }\n  const splitDate = date.split(/-|\\+|Z/);\n  const year = splitDate[0];\n  const month = splitDate[1];\n  const day = splitDate[2];\n  const truncatedMonth = month.replace(/^0+/, \"\");\n  switch (dateFormat) {\n    case \"locale\":\n      return validDate.toLocaleDateString();\n    case \"YYYY.MM.DD\":\n      return `${year}.${month}.${day}`;\n    case \"DD.MM.YYYY\":\n      return `${day}.${month}.${year}`;\n    case \"MM/DD/YYYY\":\n      return `${month}/${day}/${year}`;\n    case \"Mmm DD, YYYY\":\n      return `${monthToShortMon[truncatedMonth]} ${day}, ${year}`;\n    default:\n      return date;\n  }\n}\nexport function formatTime(time, timeFormat) {\n  if (time === undefined || time === null) {\n    return time;\n  }\n  const splitTime = time.split(/:|Z/);\n  if (splitTime.length < 3) {\n    return time;\n  }\n  const validTime = new Date();\n  validTime.setHours(Number.parseInt(splitTime[0], 10));\n  validTime.setMinutes(Number.parseInt(splitTime[1], 10));\n  const splitSeconds = splitTime[2].split(\".\");\n  validTime.setSeconds(\n    Number.parseInt(splitSeconds[0], 10),\n    Number.parseInt(splitSeconds[1], 10)\n  );\n  if (validTime.toString() === invalidDateStr) {\n    return time;\n  }\n  switch (timeFormat) {\n    case \"locale\":\n      return validTime.toLocaleTimeString();\n    case \"hours24\":\n      return validTime.toLocaleTimeString(\"en-gb\");\n    case \"hours12\":\n      return validTime.toLocaleTimeString(\"en-us\");\n    default:\n      return time;\n  }\n}\nexport function formatDateTime(dateTimeStr, dateTimeFormat) {\n  if (dateTimeStr === undefined || dateTimeStr === null) {\n    return dateTimeStr;\n  }\n  const dateTime = /^d+$/.test(dateTimeStr)\n    ? new Date(Number.parseInt(dateTimeStr, 10))\n    : new Date(Date.parse(dateTimeStr));\n  if (dateTime.toString() === invalidDateStr) {\n    return dateTimeStr;\n  }\n  if (dateTimeFormat === \"locale\") {\n    return dateTime.toLocaleString();\n  }\n  const dateAndTime = dateTime.toISOString().split(\"T\");\n  const date = formatDate(dateAndTime[0], dateTimeFormat.dateFormat);\n  const time = formatTime(dateAndTime[1], dateTimeFormat.timeFormat);\n  return `${date} - ${time}`;\n}\nexport function formatter(value, formatterInput) {\n  switch (formatterInput.type) {\n    case \"DateFormat\":\n      return formatDate(value, formatterInput.format);\n    case \"DateTimeFormat\":\n      return formatDateTime(value, formatterInput.format);\n    case \"TimeFormat\":\n      return formatTime(value, formatterInput.format);\n    default:\n      return value;\n  }\n}\nexport const fetchByPath = (input, path = \"\", accumlator = []) => {\n  const currentPath = path.split(\".\");\n  const head = currentPath.shift();\n  if (input && head && input[head] !== undefined) {\n    if (!currentPath.length) {\n      accumlator.push(input[head]);\n    } else {\n      fetchByPath(input[head], currentPath.join(\".\"), accumlator);\n    }\n  }\n  return accumlator[0];\n};\nexport const processFile = async ({ file }) => {\n  const fileExtension = file.name.split(\".\").pop();\n  return file\n    .arrayBuffer()\n    .then((filebuffer) => window.crypto.subtle.digest(\"SHA-1\", filebuffer))\n    .then((hashBuffer) => {\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      const hashHex = hashArray\n        .map((a) => a.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n      return { file, key: `${hashHex}.${fileExtension}` };\n    });\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,MAAMA,aAAa,GAAGA,CAACC,KAAK,EAAEC,WAAW,KAAK;EACnD,KAAK,MAAMC,UAAU,IAAID,WAAW,EAAE;IACpC,IAAID,KAAK,KAAKG,SAAS,IAAIH,KAAK,KAAK,EAAE,IAAIA,KAAK,KAAK,IAAI,EAAE;MACzD,IAAIE,UAAU,CAACE,IAAI,KAAK,UAAU,EAAE;QAClC,OAAO;UACLC,QAAQ,EAAE,IAAI;UACdC,YAAY,EAAEJ,UAAU,CAACK,iBAAiB,IAAI;QAChD,CAAC;MACH,CAAC,MAAM;QACL,OAAO;UACLF,QAAQ,EAAE;QACZ,CAAC;MACH;IACF;IACA,MAAMG,gBAAgB,GAAGC,eAAe,CAACT,KAAK,EAAEE,UAAU,CAAC;IAC3D,IAAIM,gBAAgB,aAAhBA,gBAAgB,eAAhBA,gBAAgB,CAAEH,QAAQ,EAAE;MAC9B,OAAOG,gBAAgB;IACzB;EACF;EACA,OAAO;IAAEH,QAAQ,EAAE;EAAM,CAAC;AAC5B,CAAC;AACD,OAAO,MAAMK,kBAAkB,GAAIC,aAAa,IAAK;EACnD,MAAMC,WAAW,GACd,GAAEC,QAAQ,CAACF,aAAa,CAAE,EAAC,CAACG,MAAM,KAAKH,aAAa,CAACG,MAAM;EAC9D,OAAOF,WAAW,GAAGC,QAAQ,CAACF,aAAa,CAAC,GAAGA,aAAa;AAC9D,CAAC;AACD,MAAMF,eAAe,GAAGA,CAACT,KAAK,EAAEE,UAAU,KAAK;EAAA,IAAAa,qBAAA,EAAAC,qBAAA;EAC7C,KAAAD,qBAAA,GAAIb,UAAU,CAACe,SAAS,cAAAF,qBAAA,eAApBA,qBAAA,CAAsBD,MAAM,EAAE;IAChC,QAAQZ,UAAU,CAACE,IAAI;MACrB,KAAK,cAAc;QACjB,OAAO;UACLC,QAAQ,EAAE,EAAEL,KAAK,CAACc,MAAM,IAAIZ,UAAU,CAACe,SAAS,CAAC,CAAC,CAAC,CAAC;UACpDX,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,kCAAiCL,UAAU,CAACe,SAAS,CAAC,CAAC,CAAE;QAC9D,CAAC;MACH,KAAK,iBAAiB;QACpB,OAAO;UACLZ,QAAQ,EAAE,EAAEL,KAAK,CAACc,MAAM,GAAGZ,UAAU,CAACe,SAAS,CAAC,CAAC,CAAC,CAAC;UACnDX,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,iCAAgCL,UAAU,CAACe,SAAS,CAAC,CAAC,CAAE;QAC7D,CAAC;MACH,KAAK,aAAa;QAChB,OAAO;UACLZ,QAAQ,EAAE,EAAEL,KAAK,GAAGE,UAAU,CAACe,SAAS,CAAC,CAAC,CAAC,CAAC;UAC5CX,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,+BAA8BL,UAAU,CAACe,SAAS,CAAC,CAAC,CAAE;QAC3D,CAAC;MACH,KAAK,gBAAgB;QACnB,OAAO;UACLZ,QAAQ,EAAE,EAAEL,KAAK,GAAGE,UAAU,CAACe,SAAS,CAAC,CAAC,CAAC,CAAC;UAC5CX,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,kCAAiCL,UAAU,CAACe,SAAS,CAAC,CAAC,CAAE;QAC9D,CAAC;MACH,KAAK,SAAS;QACZ,OAAO;UACLZ,QAAQ,EAAE,CAACH,UAAU,CAACe,SAAS,CAACC,IAAI,CAAEC,EAAE,IAAKA,EAAE,KAAKnB,KAAK,CAAC;UAC1DM,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,8BAA6BL,UAAU,CAACe,SAAS,CAACG,IAAI,CAAC,MAAM,CAAE;QACpE,CAAC;MACH;IACF;EACF,CAAC,MAAM,KAAAJ,qBAAA,GAAId,UAAU,CAACmB,SAAS,cAAAL,qBAAA,eAApBA,qBAAA,CAAsBF,MAAM,EAAE;IACvC,QAAQZ,UAAU,CAACE,IAAI;MACrB,KAAK,WAAW;QACd,OAAO;UACLC,QAAQ,EAAE,CAACH,UAAU,CAACmB,SAAS,CAACH,IAAI,CAAEC,EAAE,IAAKnB,KAAK,CAACsB,UAAU,CAACH,EAAE,CAAC,CAAC;UAClEb,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,6BAA4BL,UAAU,CAACmB,SAAS,CAACD,IAAI,CAAC,IAAI,CAAE;QACjE,CAAC;MACH,KAAK,SAAS;QACZ,OAAO;UACLf,QAAQ,EAAE,CAACH,UAAU,CAACmB,SAAS,CAACH,IAAI,CAAEC,EAAE,IAAKnB,KAAK,CAACuB,QAAQ,CAACJ,EAAE,CAAC,CAAC;UAChEb,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,2BAA0BL,UAAU,CAACmB,SAAS,CAACD,IAAI,CAAC,IAAI,CAAE;QAC/D,CAAC;MACH,KAAK,UAAU;QACb,OAAO;UACLf,QAAQ,EAAE,CAACH,UAAU,CAACmB,SAAS,CAACH,IAAI,CAAEC,EAAE,IAAKnB,KAAK,CAACwB,QAAQ,CAACL,EAAE,CAAC,CAAC;UAChEb,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,0BAAyBL,UAAU,CAACmB,SAAS,CAACD,IAAI,CAAC,IAAI,CAAE;QAC9D,CAAC;MACH,KAAK,aAAa;QAChB,OAAO;UACLf,QAAQ,EAAE,CAACH,UAAU,CAACmB,SAAS,CAACI,KAAK,CAAEN,EAAE,IAAK,CAACnB,KAAK,CAACwB,QAAQ,CAACL,EAAE,CAAC,CAAC;UAClEb,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,8BAA6BL,UAAU,CAACmB,SAAS,CAACD,IAAI,CAAC,IAAI,CAAE;QAClE,CAAC;MACH,KAAK,SAAS;QACZ,OAAO;UACLf,QAAQ,EAAE,EACR,IAAIqB,IAAI,CAAC1B,KAAK,CAAC,GACf,IAAI0B,IAAI,CAAChB,kBAAkB,CAACR,UAAU,CAACmB,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CACtD;UACDf,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,2BAA0BL,UAAU,CAACmB,SAAS,CAAC,CAAC,CAAE;QACvD,CAAC;MACH,KAAK,UAAU;QACb,OAAO;UACLhB,QAAQ,EAAE,EACR,IAAIqB,IAAI,CAAC1B,KAAK,CAAC,GACf,IAAI0B,IAAI,CAAChB,kBAAkB,CAACR,UAAU,CAACmB,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CACtD;UACDf,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC3B,4BAA2BL,UAAU,CAACmB,SAAS,CAAC,CAAC,CAAE;QACxD,CAAC;IACL;EACF;EACA,QAAQnB,UAAU,CAACE,IAAI;IACrB,KAAK,OAAO;MACV,MAAMuB,mBAAmB,GACvB,iIAAiI;MACnI,OAAO;QACLtB,QAAQ,EAAE,CAACsB,mBAAmB,CAACC,IAAI,CAAC5B,KAAK,CAAC;QAC1CM,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC5B;MACJ,CAAC;IACH,KAAK,MAAM;MACT,IAAIsB,aAAa,GAAG,KAAK;MACzB,IAAI;QACFC,IAAI,CAACC,KAAK,CAAC/B,KAAK,CAAC;MACnB,CAAC,CAAC,OAAOgC,CAAC,EAAE;QACVH,aAAa,GAAG,IAAI;MACtB;MACA,OAAO;QACLxB,QAAQ,EAAEwB,aAAa;QACvBvB,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC5B;MACJ,CAAC;IACH,KAAK,WAAW;MACd,MAAM0B,KAAK,GACT,uFAAuF;MACzF,MAAMC,KAAK,GACT,qoCAAqoC;MACvoC,OAAO;QACL7B,QAAQ,EAAE,EAAE4B,KAAK,CAACL,IAAI,CAAC5B,KAAK,CAAC,IAAIkC,KAAK,CAACN,IAAI,CAAC5B,KAAK,CAAC,CAAC;QACnDM,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC5B;MACJ,CAAC;IACH,KAAK,KAAK;MACR,IAAI4B,YAAY,GAAG,KAAK;MACxB,IAAI;QACF,IAAIC,GAAG,CAACpC,KAAK,CAAC;MAChB,CAAC,CAAC,OAAOgC,CAAC,EAAE;QACVG,YAAY,GAAG,IAAI;MACrB;MACA,OAAO;QACL9B,QAAQ,EAAE8B,YAAY;QACtB7B,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC5B;MACJ,CAAC;IACH,KAAK,OAAO;MACV,MAAM8B,KAAK,GAAG,iBAAiB;MAC/B,OAAO;QACLhC,QAAQ,EAAE,CAACgC,KAAK,CAACT,IAAI,CAAC5B,KAAK,CAAC;QAC5BM,YAAY,EACVJ,UAAU,CAACK,iBAAiB,IAC5B;MACJ,CAAC;IACH;EACF;AACF,CAAC;AACD,MAAM+B,eAAe,GAAG;EACtB,GAAG,EAAE,KAAK;EACV,GAAG,EAAE,KAAK;EACV,GAAG,EAAE,KAAK;EACV,GAAG,EAAE,KAAK;EACV,GAAG,EAAE,KAAK;EACV,GAAG,EAAE,KAAK;EACV,GAAG,EAAE,KAAK;EACV,GAAG,EAAE,KAAK;EACV,GAAG,EAAE,KAAK;EACV,IAAI,EAAE,KAAK;EACX,IAAI,EAAE,KAAK;EACX,IAAI,EAAE;AACR,CAAC;AACD,MAAMC,cAAc,GAAG,cAAc;AACrC,OAAO,SAASC,UAAUA,CAACC,IAAI,EAAEC,UAAU,EAAE;EAC3C,IAAID,IAAI,KAAKtC,SAAS,IAAIsC,IAAI,KAAK,IAAI,EAAE;IACvC,OAAOA,IAAI;EACb;EACA,MAAME,SAAS,GAAG,IAAIjB,IAAI,CAACA,IAAI,CAACK,KAAK,CAACU,IAAI,CAAC,CAAC;EAC5C,IAAIE,SAAS,CAACC,QAAQ,CAAC,CAAC,KAAKL,cAAc,EAAE;IAC3C,OAAOE,IAAI;EACb;EACA,MAAMI,SAAS,GAAGJ,IAAI,CAACK,KAAK,CAAC,QAAQ,CAAC;EACtC,MAAMC,IAAI,GAAGF,SAAS,CAAC,CAAC,CAAC;EACzB,MAAMG,KAAK,GAAGH,SAAS,CAAC,CAAC,CAAC;EAC1B,MAAMI,GAAG,GAAGJ,SAAS,CAAC,CAAC,CAAC;EACxB,MAAMK,cAAc,GAAGF,KAAK,CAACG,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;EAC/C,QAAQT,UAAU;IAChB,KAAK,QAAQ;MACX,OAAOC,SAAS,CAACS,kBAAkB,CAAC,CAAC;IACvC,KAAK,YAAY;MACf,OAAQ,GAAEL,IAAK,IAAGC,KAAM,IAAGC,GAAI,EAAC;IAClC,KAAK,YAAY;MACf,OAAQ,GAAEA,GAAI,IAAGD,KAAM,IAAGD,IAAK,EAAC;IAClC,KAAK,YAAY;MACf,OAAQ,GAAEC,KAAM,IAAGC,GAAI,IAAGF,IAAK,EAAC;IAClC,KAAK,cAAc;MACjB,OAAQ,GAAET,eAAe,CAACY,cAAc,CAAE,IAAGD,GAAI,KAAIF,IAAK,EAAC;IAC7D;MACE,OAAON,IAAI;EACf;AACF;AACA,OAAO,SAASY,UAAUA,CAACC,IAAI,EAAEC,UAAU,EAAE;EAC3C,IAAID,IAAI,KAAKnD,SAAS,IAAImD,IAAI,KAAK,IAAI,EAAE;IACvC,OAAOA,IAAI;EACb;EACA,MAAME,SAAS,GAAGF,IAAI,CAACR,KAAK,CAAC,KAAK,CAAC;EACnC,IAAIU,SAAS,CAAC1C,MAAM,GAAG,CAAC,EAAE;IACxB,OAAOwC,IAAI;EACb;EACA,MAAMG,SAAS,GAAG,IAAI/B,IAAI,CAAC,CAAC;EAC5B+B,SAAS,CAACC,QAAQ,CAACC,MAAM,CAAC9C,QAAQ,CAAC2C,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EACrDC,SAAS,CAACG,UAAU,CAACD,MAAM,CAAC9C,QAAQ,CAAC2C,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EACvD,MAAMK,YAAY,GAAGL,SAAS,CAAC,CAAC,CAAC,CAACV,KAAK,CAAC,GAAG,CAAC;EAC5CW,SAAS,CAACK,UAAU,CAClBH,MAAM,CAAC9C,QAAQ,CAACgD,YAAY,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EACpCF,MAAM,CAAC9C,QAAQ,CAACgD,YAAY,CAAC,CAAC,CAAC,EAAE,EAAE,CACrC,CAAC;EACD,IAAIJ,SAAS,CAACb,QAAQ,CAAC,CAAC,KAAKL,cAAc,EAAE;IAC3C,OAAOe,IAAI;EACb;EACA,QAAQC,UAAU;IAChB,KAAK,QAAQ;MACX,OAAOE,SAAS,CAACM,kBAAkB,CAAC,CAAC;IACvC,KAAK,SAAS;MACZ,OAAON,SAAS,CAACM,kBAAkB,CAAC,OAAO,CAAC;IAC9C,KAAK,SAAS;MACZ,OAAON,SAAS,CAACM,kBAAkB,CAAC,OAAO,CAAC;IAC9C;MACE,OAAOT,IAAI;EACf;AACF;AACA,OAAO,SAASU,cAAcA,CAACC,WAAW,EAAEC,cAAc,EAAE;EAC1D,IAAID,WAAW,KAAK9D,SAAS,IAAI8D,WAAW,KAAK,IAAI,EAAE;IACrD,OAAOA,WAAW;EACpB;EACA,MAAME,QAAQ,GAAG,MAAM,CAACvC,IAAI,CAACqC,WAAW,CAAC,GACrC,IAAIvC,IAAI,CAACiC,MAAM,CAAC9C,QAAQ,CAACoD,WAAW,EAAE,EAAE,CAAC,CAAC,GAC1C,IAAIvC,IAAI,CAACA,IAAI,CAACK,KAAK,CAACkC,WAAW,CAAC,CAAC;EACrC,IAAIE,QAAQ,CAACvB,QAAQ,CAAC,CAAC,KAAKL,cAAc,EAAE;IAC1C,OAAO0B,WAAW;EACpB;EACA,IAAIC,cAAc,KAAK,QAAQ,EAAE;IAC/B,OAAOC,QAAQ,CAACC,cAAc,CAAC,CAAC;EAClC;EACA,MAAMC,WAAW,GAAGF,QAAQ,CAACG,WAAW,CAAC,CAAC,CAACxB,KAAK,CAAC,GAAG,CAAC;EACrD,MAAML,IAAI,GAAGD,UAAU,CAAC6B,WAAW,CAAC,CAAC,CAAC,EAAEH,cAAc,CAACxB,UAAU,CAAC;EAClE,MAAMY,IAAI,GAAGD,UAAU,CAACgB,WAAW,CAAC,CAAC,CAAC,EAAEH,cAAc,CAACX,UAAU,CAAC;EAClE,OAAQ,GAAEd,IAAK,MAAKa,IAAK,EAAC;AAC5B;AACA,OAAO,SAASiB,SAASA,CAACvE,KAAK,EAAEwE,cAAc,EAAE;EAC/C,QAAQA,cAAc,CAACpE,IAAI;IACzB,KAAK,YAAY;MACf,OAAOoC,UAAU,CAACxC,KAAK,EAAEwE,cAAc,CAACC,MAAM,CAAC;IACjD,KAAK,gBAAgB;MACnB,OAAOT,cAAc,CAAChE,KAAK,EAAEwE,cAAc,CAACC,MAAM,CAAC;IACrD,KAAK,YAAY;MACf,OAAOpB,UAAU,CAACrD,KAAK,EAAEwE,cAAc,CAACC,MAAM,CAAC;IACjD;MACE,OAAOzE,KAAK;EAChB;AACF;AACA,OAAO,MAAM0E,WAAW,GAAGA,CAACC,KAAK,EAAEC,IAAI,GAAG,EAAE,EAAEC,UAAU,GAAG,EAAE,KAAK;EAChE,MAAMC,WAAW,GAAGF,IAAI,CAAC9B,KAAK,CAAC,GAAG,CAAC;EACnC,MAAMiC,IAAI,GAAGD,WAAW,CAACE,KAAK,CAAC,CAAC;EAChC,IAAIL,KAAK,IAAII,IAAI,IAAIJ,KAAK,CAACI,IAAI,CAAC,KAAK5E,SAAS,EAAE;IAC9C,IAAI,CAAC2E,WAAW,CAAChE,MAAM,EAAE;MACvB+D,UAAU,CAACI,IAAI,CAACN,KAAK,CAACI,IAAI,CAAC,CAAC;IAC9B,CAAC,MAAM;MACLL,WAAW,CAACC,KAAK,CAACI,IAAI,CAAC,EAAED,WAAW,CAAC1D,IAAI,CAAC,GAAG,CAAC,EAAEyD,UAAU,CAAC;IAC7D;EACF;EACA,OAAOA,UAAU,CAAC,CAAC,CAAC;AACtB,CAAC;AACD,OAAO,MAAMK,WAAW,GAAG,MAAAA,CAAO;EAAEC;AAAK,CAAC,KAAK;EAC7C,MAAMC,aAAa,GAAGD,IAAI,CAACE,IAAI,CAACvC,KAAK,CAAC,GAAG,CAAC,CAACwC,GAAG,CAAC,CAAC;EAChD,OAAOH,IAAI,CACRI,WAAW,CAAC,CAAC,CACbC,IAAI,CAAEC,UAAU,IAAKC,MAAM,CAACC,MAAM,CAACC,MAAM,CAACC,MAAM,CAAC,OAAO,EAAEJ,UAAU,CAAC,CAAC,CACtED,IAAI,CAAEM,UAAU,IAAK;IACpB,MAAMC,SAAS,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAIC,UAAU,CAACJ,UAAU,CAAC,CAAC;IACxD,MAAMK,OAAO,GAAGJ,SAAS,CACtBK,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACzD,QAAQ,CAAC,EAAE,CAAC,CAAC0D,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAC3ClF,IAAI,CAAC,EAAE,CAAC;IACX,OAAO;MAAE+D,IAAI;MAAEoB,GAAG,EAAG,GAAEJ,OAAQ,IAAGf,aAAc;IAAE,CAAC;EACrD,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}